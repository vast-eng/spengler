package com.vast.xml

import com.typesafe.scalalogging.slf4j.LazyLogging
import com.vast.util.iteratee._

/**
 * A class to incrementally and asynchronously parse an object from a stream of XMLEvents. Traditionally, XML parsing meant one of two things
 *
 *  i. Load the entire raw contents of the source XML document into memory, and parse a DOM tree from that. This method makes it easy
 *    for parsers to be written, but at the cost of memory usage. For very large input documents, this method can become unusable.
 *  i. Parse the document using the SAX or STaX APIs. This does not require that the entire contents of the input be loaded into memory at once,
 *    but it does imply that the input source (and parser) must use blocking I/O, since the parser has no way to 'pause' itself and
 *    offer clients the ability to restart later when more input is available.
 *
 * The [[com.vast.xml.ObjectParser]] is a nice balance between the two methods above. The top-level interface to this mechanism is through
 * [[com.vast.xml.ObjectParser.parseObject]].
 *
 */
object ObjectParser extends LazyLogging {

  import scala.util.control.NonFatal

  import Iteratees._
  import Combinators._

  /**
   * Transforms a stream of XMLEvent to a stream of V.
   *
   * This can be used to parse an arbitrary tree of XML. It's assumed that the first XMLEvent received
   * is the StartElement for the parent tag. The childHandler function takes in info about a child element
   * and returns an Iteratee that can parse it.
   *
   * This Enumeratee is *very* useful when the input document is very large and the goal is to parse each
   * element in place and then discard the input.
   *
   */
  def parseObject[V](childHandlerProducer: (String, Map[String, String]) => Option[Iteratee[XMLEvent, V]]): Enumeratee[XMLEvent, V] = new Enumeratee[XMLEvent, V] {

    def step[A](inner: Iteratee[V, A]): Iteratee[V, Iteratee[V, A]] = Cont {
      case Input.EOF => Done(inner, Input.EOF)
      case Input.Empty => step(inner)
      case in: Input.El[V] => step(inner.feed(in))
    }

    def applyOn[A](inner: Iteratee[V, A]): Iteratee[XMLEvent, Iteratee[V, A]] = {
      xmlObject(step(inner), childHandlerProducer)
    }
  }

  def parseObject[V](childHandlers: (String, Iteratee[XMLEvent, V])*): Enumeratee[XMLEvent, V] = {
    parseObject(childHandlers.toMap)
  }

  def parseObject[V](childHandlers: Map[String, Iteratee[XMLEvent, V]]): Enumeratee[XMLEvent, V] =
    parseObject { (name, attrs) =>
     childHandlers.get(name)
    }


  def required[A](it: Iteratee[XMLEvent, Option[A]]) = {
    it.flatMap { value =>
      value.map(Done[XMLEvent, A](_)).getOrElse(Error(new IterateeException("Missing or blank required value."), Input.Empty))
    }
  }

  //Handy typedefs to use when processing streams of values
  type Updater[Result] = Result => Result
  type ValueUpdater[Result, V] = V => Updater[Result]


  /**
   * This looks way more complex than it really is.
   *
   * This function does the following -
   *   1) It takes as an argument a function that takes a Result and a Value, and returns Unit. It's assumed
   *      that when executed, this function will set some value or change some state on the Result, likely
   *      based on the Value itself.
   *   2) Since this function has two argument lists, only supplying the first set of arguments partially applies it, which means
   *      the result is a new function that takes as it's input a value of type Value and returns an Updater[Result].
   *   3) This Updater[Result] is a function that takes a Result, and then calls the function supplied in #1 above with
   *      the Result along with the Value, and returns the Result.
   *
   * Basically, this allows us to map the output of a given parsing step that produces a Value into a function
   * that takes a Result and sets that value on the result.
   *
   * To simplify things a bit, think of it this way -
   *  Ultimately, we want the Enumeratee generated by parseObject to generate a stream of Updater[Result] functions.
   *  An updater is a function that does nothing more than take a Result and return a Result, possibly updating it
   *  along the way. This function is a nice shorthand for generating an Updater by passing it's result to the map() function
   *  of an iteratee - map() takes in a function Value => Updater, and the result of valueUpdater is exactly that.
   *  The iteratee maps it's output Value to an Updater function, which is then collected and run
   *  out of band to update the state of the parse result.
   */
  def valueUpdater[Result, Value](updater: (Result, Value) => Unit)(value: Value): Updater[Result] = {
    result: Result => updater(result, value); result
  }

  //Syntactic sugar for the following -
  //   valueUpdater( (result: Result, value: Value) => result.setSomeValue(value) )
  //is exactly equal to -
  //   simpleValueUpdater( res => res.setSomeValue )
  //where setSomeValue is a Bean-style setter that takes an argument of type Value
  // - or, even better
  //   simpleValueUpdater(_.setSomeValue)
  def simpleValueUpdater[Result, Value](updater: (Result) => (Value => Unit)): ValueUpdater[Result, Value] = {
    valueUpdater { (result: Result, value: Value) => updater(result)(value) }
  }

  /**
   * Returns an iteratee that can take a stream of Updater[Result] functions and apply them to an instance of Result.
   * When the Iteratee has finished, the Result has had all of the relevant changes parsed from the stream applied to it.
   *
   * This is used when the initial state is mutable and a new instance is required for every parse - basically this creates
   * an Iteratee who's first step is to create a new Result object, and then fold a series up Updater functions across it.
   */
  def producer[Result](initialState: () => Result): Iteratee[Updater[Result], Result] = {
    Cont { input: Input[Updater[Result]] =>
      Done[Updater[Result], Result](initialState(), input)
    }.flatMap(state => updater(state))
  }

  /**
   * An interatee that applies a series of updater functions across an initial state. Note - the initial state
   * value should be immutable and the updater functions should be pure with no side effects. If this is not true,
   * please use the producer method instead, which creates a new initial state on every invocation of the initial
   * Iteratee.
   */
  def updater[Result](initialState: Result): Iteratee[Updater[Result], Result] = {
    Iteratee.fold[Updater[Result], Result](initialState) {
      case (result, updater) => updater(result)
    }
  }

  def xmlString = textOnly

  def xmlNumber = textOnly.flatMap { numberOpt =>
    try {
      Done(numberOpt.map(x => BigDecimal(x)))
    } catch {
      case e: NumberFormatException => Error(new IterateeException(s"Unable to parse $numberOpt into a number.", e), Input.Empty)
    }
  }

  def xmlObject[A, V](elementsAggregator: Iteratee[V, A],
                      elementHandlerProducer: (String, Map[String, String]) => Option[Iteratee[XMLEvent, V]]): Iteratee[XMLEvent, A] =
    for {
      _ <- expectStartElement
      elements <- childElements(elementsAggregator, elementHandlerProducer)
    } yield elements

  private[this] def childElements[A, V](elementsAggregator: Iteratee[V, A],
                                        elementHandlerProducer: (String, Map[String, String]) => Option[Iteratee[XMLEvent, V]]): Iteratee[XMLEvent, A] =
    skipToNextStartOrEnd.flatMap {
      case e: StartElement =>
        childElement(elementHandlerProducer).feed(Input.El(e)).flatMap { childValueOpt =>
          val fed = if(childValueOpt.isDefined) {
            elementsAggregator.feed(Input.El(childValueOpt.get))
          } else {
            elementsAggregator
          }
          childElements(fed, elementHandlerProducer)
        }
      case e: EndElement =>
        elementsAggregator.run.map(a => Done[XMLEvent, A](a)).recover({ case NonFatal(t) => Error[XMLEvent](t, Input.Empty)}).get
      case x => Error(new IterateeException(s"Expecting StartElement or EndElement, got $x instead."), Input.Empty)
    }

  private[this] def childElement[V](elementHandlerProducer: (String, Map[String, String]) => Option[Iteratee[XMLEvent, V]]): Iteratee[XMLEvent, Option[V]] = Cont {
    case Input.El(event) => event match {
      case x@StartElement(name, attrs) =>
        elementHandlerProducer(name, attrs).map { handler =>
          handler.feed(Input.El(x)).map(res => Some(res))
        } getOrElse {
          //if there's no handler, consume the element and return None
          ignoreElement.feed(Input.El(x)).map(x => None)
        }
      case x => Error(new IterateeException(s"Expected StartElement, got $x instead"), Input.Empty)
    }
    case Input.Empty => childElement(elementHandlerProducer)
    case Input.EOF => Error(new IterateeException("Unexpected EOF parsing child element."), Input.Empty)
  }
}
